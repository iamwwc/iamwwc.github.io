<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="广阔天地，大有可为"><title>Rust浅尝 | 胖成煤气罐</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><style type="text/css">.icon {
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}</style><script src="//at.alicdn.com/t/font_1484091_u5pgqyl62w9.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-148409521-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Rust浅尝</h1><a id="logo" href="/.">胖成煤气罐</a><p class="description">广阔天地，大有可为</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Rust浅尝</h1><div class="post-meta"><div class="post-date">2020-11-01</div><div class="post-tags"> | <a class="post-tag" href="/tags/Rust/">Rust</a><a class="post-tag" href="/tags/编程语言/">编程语言</a></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 30</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h1 id="Rust-基本语法学习"><a href="#Rust-基本语法学习" class="headerlink" title="Rust 基本语法学习"></a>Rust 基本语法学习</h1><h2 id="为什么会有此文"><a href="#为什么会有此文" class="headerlink" title="为什么会有此文"></a>为什么会有此文</h2><p>目标是给 Deno 项目贡献代码，结果发现我还不会 Rust ……，所以要先啃 Rust</p>
<p>我发现 rust，ruby 和掌握的 C 系风格语言很不同。</p>
<p>我从 C# 转 Java 时根本没花时间『特地』学习语法，因为他们两个太像了，直接找了一份开源代码对着抄，边抄边查文档就会了。</p>
<p>然而当我开始学 Rust 时我看到这语法就蒙蔽了。</p>
<p>你很习惯用之前的经验来套，结果发现，卧槽，你 <code>return</code> 哪去了， for 循环呢？ <code>&#39;static</code>又是个啥，好不容易看到个 &lt;T&gt; 以为碰到泛型了，结果后面的 where 又是个啥，搜完才发现类似于 T extends String。</p>
<p>语法都看不懂何谈抄？</p>
<p>所以决定将我 抄 官方文档的 example 和开源代码的过程作为笔记沉淀下来 :)</p>
<p>开始正文</p>
<p>学了这么多语言，我也有自己的学习流程</p>
<ol>
<li>模块系统，如何引入类（相对，绝对路径），模块的最小单元是由约束，关键词？文件？</li>
<li>类型系统，是否区分 primitive 和 Object， pass by value or reference?</li>
<li>GC系统</li>
<li>生态系统，有包管理器吗，如何安装第三方包</li>
<li>线程模型，1:1 还是 M:N，是否实现了 yield, await, async, Promise, Future 等等异步模型</li>
<li>语言特性，Green Thread，Ownership等等</li>
<li>关键字，预处理，宏定义等杂项</li>
</ol>
<p>上述七步互相穿插并持续配合官方文档，知乎文章，搜索引擎</p>
<h2 id="模块引用-模块系统"><a href="#模块引用-模块系统" class="headerlink" title="模块引用-模块系统"></a>模块引用-模块系统</h2><p>这是某个文件的内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">use crate::&#123;event, sys, Events, Interest, Token&#125;;</span><br><span class="line">use log::trace;</span><br><span class="line">#[cfg(unix)]</span><br><span class="line">use std::os::unix::io::&#123;AsRawFd, RawFd&#125;;</span><br><span class="line">use std::time::Duration;</span><br><span class="line">use std::&#123;fmt, io&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，对于自己包使用 use crate，当引用外部包时使用 use std:: 或者 use log::trace<br>std:: 是 rust 的标准库</p>
<p>rust的模块系统是个树形结构，全部模块都挂载到 crate 这个root上，而以 <code>crate::xxx</code> 的方式引用模块被称为 绝对路径 引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   ├── add_to_waitlist</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         ├── serve_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use crate::&#123;event, sys&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line"> └── event</span><br><span class="line">     ├── mod.rs</span><br><span class="line">     │</span><br><span class="line">     │</span><br><span class="line">     sys </span><br><span class="line">     ├─ mod.rs</span><br></pre></td></tr></table></figure>

<p>引用自己的代码用 crate 开头，比如 use crate::{ event };</p>
<p>如果是外部库比如 log，就使用 use log;</p>
<p>use park;</p>
<ol>
<li>首先查找 park.rs，找到停止</li>
<li>查找park/mod.rs文件</li>
</ol>
<p>上述查找算法不运行同时拥有 park/mod.rs 和 park.rs</p>
<p>(pub)mod park;(向外)声明模块，使用上述查找算法</p>
<p><strong>注意</strong></p>
<p>Rust中不以文件，而以 mod 关键字定义模块，如果你的文件没有 mod 关键词，那你的代码就挂载在父文件夹所在的模块</p>
<p>mod event; 向编译器声明一个模块，这样编译器才知道这个模块的存在并将其引入到 module tree 里，如下图所示</p>
<p><img src="https://user-images.githubusercontent.com/24750337/97392445-bddba800-191c-11eb-8991-ff8cc2d155b9.png" alt="image"></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/event/event.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Event</span></span> &#123;</span><br><span class="line">    inner: sys::Event,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这点和 js，python很不同</span></span><br><span class="line"><span class="comment">// js 使用文件路径直接就可以查找，而不需要先声明存在这个模块</span></span><br><span class="line"><span class="comment">// src/event/mod.rs</span></span><br><span class="line"><span class="keyword">mod</span> event;</span><br><span class="line"><span class="keyword">mod</span> events;</span><br><span class="line"><span class="keyword">mod</span> source;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::event::Event;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::events::&#123;Events, Iter&#125;;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::source::Source;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>use crate::event::Event; </p>
<ol>
<li>找到src/</li>
<li>找到event/mod.rs，发现定义了 event 模块(mod event;)</li>
<li>event.rs 中 pub 将Event从 event.rs 模块导出</li>
<li>pub use self::events::Event 先将模块导入 mod.rs 之后利用 pub 二次导出</li>
<li>于是可以访问 Event struct</li>
</ol>
</blockquote>
<p>struct 只是个Item，可以替换为 function, trait</p>
<p>pub 会将 item 挂载到上一级 mod，如果直接在src/ 目录下，那就挂载到 crate 这个 Root module</p>
<h3 id="约定优于配置"><a href="#约定优于配置" class="headerlink" title="约定优于配置"></a>约定优于配置</h3><p>我们的代码往往有两种用途</p>
<h5 id="作为-binary"><a href="#作为-binary" class="headerlink" title="作为 binary"></a>作为 binary</h5><p>rust约定当 src/main.rs 存在时rust可以生成可执行文件</p>
<h4 id="作为-library"><a href="#作为-library" class="headerlink" title="作为 library"></a>作为 library</h4><p>rust约定当 src/lib.rs 存在时 rust作为库文件使用，引用这个库时 rust 会读取 src/lib.rs 的信息</p>
<p>src/main.rs 和 src/lib.rs 可以共存，这时项目既可作为 binary 又可为 library，你引用库时需要使用库名</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[package]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"minigrep"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"iamwwc &lt;qaq1362211689@gmail.com&gt;"</span>]</span><br><span class="line"><span class="attr">edition</span> = <span class="string">"2018"</span></span><br></pre></td></tr></table></figure>

<p>在main.rs引用lib时按照下面方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use minigrep::print;</span><br></pre></td></tr></table></figure>

<p>这很好理解，当开发者用你的库时也是以库名开头，这样 rust 才知道你引用的是谁，所以使用库名引用自己库代码时可提供一致的体验。</p>
<h5 id="mod-utils和-use-utils的区别是"><a href="#mod-utils和-use-utils的区别是" class="headerlink" title="mod utils和 use utils的区别是"></a>mod utils和 use utils的区别是</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mod utils;</span><br><span class="line">use utils::print;</span><br></pre></td></tr></table></figure>

<p>mod告诉 rust 这里存在一个 module utils，请去找到 <code>utils/lib.rs</code> 或者 <code>utils.rs</code> 并挂载到 rust 的模块树</p>
<p>use 是将<strong>已经</strong>挂载到 模块树 的符号引入当前 scope，所以不要看到 use 就想到 name lookup 和 图 理论。</p>
<p>所以我们在 main 里为了使用自己的 mod，需要先 mod 声明挂载到模块树，然后 use 将符号引入 scope，main是入口点，main 之前并没有引入别的mod，所以我们要先 mod xxx 声明。</p>
<p>Rust 会从 main.rs 或者 lib.rs 这个Root开始寻找 mod xxx 来进行模块查找并挂载到 crate root</p>
<p>这和 JS 很不同， import 会 <strong>查找并将这个符号引入</strong>，rust 拆成了两步 </p>
<p>和 Java 也不同, import com.chaochaogege.utils; 会 <strong>查找并引入</strong> 这个 class</p>
<p><a href="https://github.com/rust-lang/book/issues/460" target="_blank" rel="noopener">https://github.com/rust-lang/book/issues/460</a></p>
<hr>
<p><code>use a::b::c</code> 中的 a 一定要是 lib名字</p>
<p>比如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己库 error 下的 bad_resource_id</span></span><br><span class="line"><span class="comment">// 这里查找到了 src/error.rs 文件下的 bad_resource_id</span></span><br><span class="line"><span class="keyword">use</span> crate::error::bad_resource_id;</span><br><span class="line"><span class="comment">//第三方库 serde_json 下的 json</span></span><br><span class="line"><span class="keyword">use</span> serde_json::json;</span><br><span class="line"><span class="comment">// 标准库 std 下的 pin::Pin</span></span><br><span class="line"><span class="keyword">use</span> std::pin::Pin;</span><br></pre></td></tr></table></figure>

<h4 id="C-的模块系统"><a href="#C-的模块系统" class="headerlink" title="C++ 的模块系统"></a>C++ 的模块系统</h4><p>我想尝试理解 rust 的模块系统为什么这么设计，所以借这个机会谈一下 CPP 模块系统</p>
<p>我们都有个习惯，http.h 存放 http 函数的声明，而http.cc 包含着 http 具体的实现逻辑</p>
<p>当你在main函数引用 http 的实现时会这样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"http.h"</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// http.cc</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"http.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们并没有在任何地方引用 http.cc ，那最后编译器如何将你的实现引入呢？</p>
<p>关键点在编译你的项目时你需要 gcc main.cpp http.cc -o main</p>
<p>编译器看到 main 中引用了 http.h，他就会在符号表记录这个符号，但他并不知道这个符号到底在哪，所以我们需要主动将这个 http.cc 文件编译进去，生成 http.o，编译器发现 http.o 中的 run 在 http.h 对应后，会将符号表中对应的符号地址替换成 run。</p>
<p>当然，我们编译大型项目时往往借助 makefile，makefile中指定你想要编译的全部 xx.cc 文件，linker会将这些 xxx.o 连接。</p>
<p>这和 rust 有什么相似点呢？</p>
<p>mod xxx; 向编译器声明这个模块的存在，xxx</p>
<p>use xxx; 编译器会查找这个模块，这样不需要我们和 cpp 一样指定全部要编译的文件。</p>
<h2 id="函数返回"><a href="#函数返回" class="headerlink" title="函数返回"></a>函数返回</h2><p>语句结束要加分号，如果没有分号表示 return</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiple</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_numer_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="comment">// 由于 parse 可能发生异常，这里返回Result，OK可以将如果成功的值解析出来</span></span><br><span class="line">    <span class="keyword">let</span> first_number = first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line">    <span class="keyword">let</span> second_number = second_numer_str.parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line">    <span class="comment">// 这里没分号，返回了</span></span><br><span class="line">    <span class="literal">Ok</span>(first_number * second_number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果</p>
<h2 id="Traits-约束-接口"><a href="#Traits-约束-接口" class="headerlink" title="Traits 约束 - 接口"></a>Traits 约束 - 接口</h2><p>就是接口，比如下面代码， println? 默认并不支持输出 struct，就像 Java 重写 toString 后才支持输出 class， rust 中需要实现 std::fmt::display 这个 trait（接口）。</p>
<p>derive(Debug) 实现 Debug 接口，而 Debug 这个 trait 实现了 std::fmt::Display 的 fmt 接口</p>
<p>{:?} 是以 Debug 输出，需要配合 derive(Debug)</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"rect1 is &#123;:?&#125;"</span>, rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的 trait 的声明和定义，你可以看到 trait 和 generic 很像</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Add</span></span>&lt;Rhs=<span class="keyword">Self</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 类似 typescript 的 type x = () =&gt; void; 语法</span></span><br><span class="line">    <span class="comment">// 定义一个Output便于函数使用</span></span><br><span class="line">    <span class="comment">// 由于 Trait 不能被直接实例化所以 Output 并没有绑定到具体的类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, rhs: Rhs) -&gt; Self::Output;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">use</span> std::ops::Add;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Millimeters</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meters</span></span>(<span class="built_in">u32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Add&lt;Meters&gt; <span class="keyword">for</span> Millimeters &#123;</span><br><span class="line">    <span class="comment">// 我们实现 Add 这个trait时将 Output 定为 Millimeter 类型</span></span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Output</span></span> = Millimeters;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(<span class="keyword">self</span>, other: Meters) -&gt; Millimeters &#123;</span><br><span class="line">        Millimeters(<span class="keyword">self</span>.<span class="number">0</span> + (other.<span class="number">0</span> * <span class="number">1000</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Trait-和-范型区别"><a href="#Trait-和-范型区别" class="headerlink" title="Trait 和 范型区别"></a>Trait 和 范型区别</h3><p>这是 Trait</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Counter</span></span> &#123;</span><br><span class="line">    count: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Counter &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; Counter &#123;</span><br><span class="line">        Counter &#123; count: <span class="number">0</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Iterator</span> <span class="keyword">for</span> Counter &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = <span class="built_in">u32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;Self::Item&gt; &#123;</span><br><span class="line">        <span class="comment">// --snip--</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.count &lt; <span class="number">5</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.count += <span class="number">1</span>;</span><br><span class="line">            <span class="literal">Some</span>(<span class="keyword">self</span>.count)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>这是范型，调用范型函数时每次调用都需指明范型参数的具体类型 T。</p>
<p>Trait 可理解为 具体的范型，trait 只能实现一次且实现时已经指定为哪个类型实现。<br>当我们调用 trait 方法时不再需要显式传递范型参数</p>
<p><a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types" target="_blank" rel="noopener">https://doc.rust-lang.org/book/ch19-03-advanced-traits.html#specifying-placeholder-types-in-trait-definitions-with-associated-types</a></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Iterator</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">next</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="函数签名推断"><a href="#函数签名推断" class="headerlink" title="函数签名推断"></a>函数签名推断</h2><p>有人会有疑问，为什么函数上要加类型约束，难道不能从调用方传递过来的类型推断吗</p>
<p>事实上函数可能会单独存放，它并不知道谁会调用它，函数需要自身携带有关的参数信息便于编译器进行调用参数校验。</p>
<h2 id="where-keyword"><a href="#where-keyword" class="headerlink" title="where keyword"></a>where keyword</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">deregister</span></span>&lt;S&gt;(&amp;<span class="keyword">self</span>, source: &amp;<span class="keyword">mut</span> S) -&gt; io::<span class="built_in">Result</span>&lt;()&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">S: event::Source + ?<span class="built_in">Sized</span>,</span><br><span class="line">&#123;</span><br><span class="line">trace!(<span class="string">"deregistering event source from poller"</span>);</span><br><span class="line">source.deregister(<span class="keyword">self</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面说了 trait 实现接口，当涉及到泛型时还会有泛型参数约束</p>
<p>比如 Java 中 <t extends string> 要求 T 必须继承自 String，rust 可以对泛型参数 S 进行约束，event::Source 和 Sized 的合体类型</t></p>
<hr>
<h2 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> args: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt; = env::args().collect();</span><br><span class="line"><span class="comment">// 这是正确的</span></span><br><span class="line"><span class="keyword">let</span> query = &amp;args[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面代码就会出现 cannot move 的错误，究其原因是 String 类型不是 Copy 类型，String 对象内管理着一些内存，这些内存只能转移出去（move out）或者 Clone</span></span><br><span class="line"><span class="comment">// 是不是和 C++ 中的 Copy， Move语义很相似？</span></span><br><span class="line"><span class="comment">// https://stackoverflow.com/a/40075101/7529562</span></span><br><span class="line"><span class="keyword">let</span> query = args[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>

<hr>
<p>再看一个</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> contents = fs::read_to_string(config.filename).expect(<span class="string">"Something went wrong reading the file"</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125; contends are &#123;&#125;"</span>,config.filename, contents);</span><br></pre></td></tr></table></figure>

<p>上面代码运行会出这个错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">error[E0382]: borrow of moved value: `config.filename`</span><br><span class="line">  --&gt; src\main.rs:10:35</span><br><span class="line">   |</span><br><span class="line">8  |     let contents = fs::read_to_string(config.filename)</span><br><span class="line">   |                                       --------------- value moved here</span><br><span class="line">9  |         .expect(&quot;Something went wrong reading the file&quot;);</span><br><span class="line">10 |     println!(&quot;&#123;&#125; contends are &#123;&#125;&quot;,config.filename, contents);</span><br><span class="line">   |                                   ^^^^^^^^^^^^^^^ value borrowed here after move</span><br><span class="line">   |</span><br><span class="line">   = note: move occurs because `config.filename` has type `std::string::String`, which does not implement the `</span><br><span class="line">Copy` trait</span><br></pre></td></tr></table></figure>

<p>原因是 config.filename 所有(ownership) 转移到 read_to_string，println! 时没有所有权而报错</p>
<p>改为 fs::read_to_string(&amp;config.filename)，以借用 borrow 方式解决</p>
<h3 id="函数闭包"><a href="#函数闭包" class="headerlink" title="函数闭包"></a>函数闭包</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expensive_closure = |num| &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"calculating slowly..."</span>);</span><br><span class="line">    thread::sleep(Duration::from_secs(<span class="number">2</span>));</span><br><span class="line">    num</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>没错，上面这个就是 函数闭包，我知道你以为的闭包是这样子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> expensive_closure = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// xxx</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust 在文档里也解释为什么用 |num| 的形式</p>
<blockquote>
<p>this syntax was chosen because of its similarity to closure definitions in Smalltalk and Ruby.</p>
</blockquote>
<p>说白了，就是从 Ruby 借鉴(抄)过来的嘛！虽然我觉着这语法挺难看的 :)</p>
<p>下面比较几个 rust 语法定义</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span>  <span class="title">add_one_v1</span>   </span>(x: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加上 类型约束 的闭包函数定义</span></span><br><span class="line"><span class="keyword">let</span> add_one_v2 = |x: <span class="built_in">u32</span>| -&gt; <span class="built_in">u32</span> &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 去掉 类型约束 的闭包函数定义</span></span><br><span class="line"><span class="keyword">let</span> add_one_v3 = |x|             &#123; x + <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于函数体只有一个表达式，所以 &#123;&#125; 也直接去掉</span></span><br><span class="line"><span class="comment">// 和 Javascript 的 let add_one_v4 = x =&gt; x + 1 很像</span></span><br><span class="line"><span class="keyword">let</span> add_one_v4 = |x|               x + <span class="number">1</span>  ;</span><br></pre></td></tr></table></figure>

<h3 id="静态生存期-（static-Lifetime）"><a href="#静态生存期-（static-Lifetime）" class="headerlink" title="静态生存期 （static Lifetime）"></a>静态生存期 （static Lifetime）</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s: &amp;<span class="symbol">'static</span> <span class="built_in">str</span> = <span class="string">"I have a static lifetime."</span>;</span><br></pre></td></tr></table></figure>

<h2 id="所有权"><a href="#所有权" class="headerlink" title="所有权"></a>所有权</h2><p>GC 语言不需要手动清理引用，cpp 没有 GC 需要你显式调用 free，但 free 一次分配只能调用一次，多次调用会出现不可预料的问题。</p>
<p>GC 语言的问题是当引用类型作为参数传递给函数时在函数的 scope 中会有一个新的变量来承接传递过来的引用，这时同一块内存就有了两个变量引用。问题出现了，我们怎么知道什么时候才能释放这块内存呢？</p>
<p>GC 语言不需要程序员关注，因为 GC 会帮你标记引用次数并使用算法感知到什么时候能释放。</p>
<p>Rust 如果没有所有权的概念那就和 CPP 一样需要程序员手动释放内存。</p>
<p>所有权就是引用类型在传递给函数或者其他的变量时上一个变量就不允许再访问原来的内存，这时内存的所有权给了新变量。rust 通过这种方式可以确保某一时刻始终只有一个变量 hold 这块内存，当这个变量离开属于它的 scope 时就可以调 drop。</p>
<p><strong>核心点是只有一个变量持有引用</strong>，如果多个变量都持有，那在分别离开自己 scope 后多次调用 free释放同一块内存会导致 <code>memory corruption</code></p>
<p>但多个变量都持有同一块内存的引用是非常有用的，Rust也提供了Rc，Arc来实现 counted references</p>
<p>看 rust 手册时还看到了 move，copy 的概念，这个就和 cpp 差不多了，本质是一种接口的设计，程序员可以实现这些接口来规定变量赋值时到底采取什么行为，cpp 中有几个概念：移动构造函数，拷贝构造函数</p>
<p>以及右值引用</p>
<p>如果你在调用函数结束需要继续使用 s1 ，那函数必须以引用 &amp; 的方式，函数结束后所有权会还给 caller。 假如你有一个苹果，你需要别人借用之后返回给你，你可以用一个盒子把你的苹果包装起来，将这个盒子的所有权借给他（function），等借用完成盒子被销毁但你的苹果还在，其实引用（&amp;）就是一个拦截器，可以拦截 function 对于内部变量的操作。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// s is a reference to a String</span></span><br><span class="line">    s.len()</span><br><span class="line">&#125; <span class="comment">// H</span></span><br></pre></td></tr></table></figure>

<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> len = calculate_length(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// calculate_length 的 s 参数没有 &amp;，那 s1 传递给 calculate_length 时值会被move</span></span><br><span class="line"><span class="comment">// 原理是 calculate_length 中创建一个临时变量来承接 s1 的内容那 s1 就不能引用自己原来的内容了</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: <span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123; <span class="comment">// s is a reference to a String</span></span><br><span class="line">    s.len()</span><br><span class="line">&#125; <span class="comment">// H</span></span><br></pre></td></tr></table></figure>

<p>看起来 rust 隐藏了 GC 的概念，但隐藏的代价是开发者不能想使用 GC 语言一样随意的返回引用、对变量进行操作。其实习惯也没什么感知了。</p>
<p>rust 中的 &amp; 叫做 reference，你就可以认为是 cpp 中的 pointer。</p>
<p>rust 中解引用用 * 获取pointer值向的值</p>
<p>&amp; 在rust中还有一个含义，借用(borrow)，上面说了，所有权关键点最终某一个时刻只应有一个量持有引用的内存</p>
<p>但其实 Rust 还允许同时存在多个不可变引用，或者只存在一个可变引用</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="built_in">Box</span>::new(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> b = &amp;a;</span><br><span class="line"><span class="keyword">let</span> c = &amp;a;</span><br><span class="line"><span class="keyword">let</span> d = &amp;a;</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> e = &amp;a;</span><br></pre></td></tr></table></figure>

<h4 id="如何形象描述-Rust-引用呢？"><a href="#如何形象描述-Rust-引用呢？" class="headerlink" title="如何形象描述 Rust 引用呢？"></a>如何形象描述 Rust 引用呢？</h4><p><img src="https://user-images.githubusercontent.com/24750337/97800016-834f7380-1c6c-11eb-891e-ed3054b11a38.png" alt="Rust引用结构"></p>
<p>上图说明 s 只是简单存放了指向 s1 的 pointer，s 对最右侧操作需要二次寻址。二次寻址确保了当 s 不再使用可以安全 drop 掉而不影响 s1</p>
<p>理论上能获取到pointer就获得了对数据修改的能力， 但 Rust 中引用默认是 immutable，想要修改需添加 mut 修饰。</p>
<p>mut 有个限制，在同一个 scope 只允许一个变量持有 mut 的引用</p>
<p><a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references" target="_blank" rel="noopener">https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#mutable-references</a></p>
<p>下面代码编译不通过。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;, &#123;&#125;"</span>, r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling ownership v0.1.0 (file:///projects/ownership)</span><br><span class="line">error[E0499]: cannot borrow `s` as mutable more than once at a time</span><br><span class="line"> --&gt; src/main.rs:5:14</span><br><span class="line">  |</span><br><span class="line">4 |     let r1 = &amp;mut s;</span><br><span class="line">  |              ------ first mutable borrow occurs here</span><br><span class="line">5 |     let r2 = &amp;mut s;</span><br><span class="line">  |              ^^^^^^ second mutable borrow occurs here</span><br><span class="line">6 | </span><br><span class="line">7 |     println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2);</span><br><span class="line">  |                        -- first borrow later used here</span><br></pre></td></tr></table></figure>

<p>引用总结</p>
<blockquote>
<ol>
<li><p>在某一时刻，你只被允许只有 一个可变引用（mut） 或多个不可变引用</p>
</li>
<li><p>引用必须总是合法，即：引用变量必须存活到被引用变量之后</p>
</li>
</ol>
</blockquote>
<hr>
<p>下面代码编译不通过在于：对于引用类型的赋值不像其他语言的shadow copy一般，rust 会直接将 s1 持有的全部数据转移到 s2 中，从s2往后s1就不被设置为非法，不被允许访问原来的内存，这就是 Move。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1);</span><br></pre></td></tr></table></figure>

<p>借用不会move 掉 s1 的内存，而暂时允许 s2 持有 s1 引用的内存。通过 &amp; 的标记 Rust 会确保 s2 离开自己的scope时不会被调用 drop，因为 s2 的内存最终属于 s1</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = &amp;s1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;, world!"</span>, s1);</span><br></pre></td></tr></table></figure>

<hr>
<p>基本数据类型大小在编译时就可确认，stack中的数据复制性能远高于存放于 heap 的String类型，这时数据的赋值就是Copy</p>
<p>x 和 y 相等但不相同</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"x = &#123;&#125;, y = &#123;&#125;"</span>, x, y);</span><br></pre></td></tr></table></figure>

<p>我们再想一下，为什么会有所有权的概念？GC存在的意义是正确释放不再使用的 heap 内存。</p>
<p>函数调用需要调用栈 stack 的大小必须可被计算，所以我们不能将大小可变的数据存到栈</p>
<p>Rust有四种基本类型(Integer, Floating, Boolean, Character)，两种组合类型(Tuple, Array)</p>
<p>Tuple，Array长度固定，也即编译时就必须可确认大小，<strong>上面六种类型都会分配到 stack</strong></p>
<p>所有权关注的是分配到 heap 的数据类型，</p>
<p>看下面的代码，既然数组是基本类型，那函数调用时就会复制整个数组，你对 array_b 的修改不会反映到 array_a</p>
<p>这里不存在所有权转移，array_b 本质是复制了 array_a 而不是<strong>偷走</strong>了 array_a 的内存</p>
<p>为什么不偷走呢？因为 Array 类型 <strong>size fixed</strong>，编译时就可以分配好栈大小</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">p</span> </span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> array_a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    c(array_a);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">c</span> </span>(<span class="keyword">mut</span> array_b: [<span class="built_in">i32</span>;<span class="number">3</span>]) &#123;</span><br><span class="line">        array_b[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [1, 2, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,array_a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想要在 p 里修改 array_a 就需要传递指针 &amp; 并标记为可变 mut</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[test]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">p</span> </span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> array_a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">    c(&amp;<span class="keyword">mut</span> array_a);</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">c</span> </span>(<span class="keyword">mut</span> array_b: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>; <span class="number">3</span>]) &#123;</span><br><span class="line">        array_b[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// [1, 6, 3]</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>,array_a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>考虑 所有权 的关键点在于明确数据分配在 heap 中，这里为什么说是数据而不说变量呢？因为数据囊括可变和不可变，这两种都可以分配到 heap</p>
<p>具体可以读读下面链接，我记录的往往都是官方文档给的启发。</p>
<p><a href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="noopener">https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html</a></p>
<h4 id="move"><a href="#move" class="headerlink" title="move"></a>move</h4><p>下面闭包孵化了新的线程，但线程运行的时间可能长于调用函数。</p>
<p>需要明确闭包函数对外部变量的所有权归属，改为 <code>let thread = thread::spawn(move || loop {</code></p>
<p>后闭包会强行 take ownership</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">new</span> </span>(id: <span class="built_in">usize</span>, receiver: Arc&lt;Mutex&lt;mpsc::Receiver&lt;Job&gt;&gt;&gt;) -&gt; Worker &#123;</span><br><span class="line">    <span class="keyword">let</span> thread = thread::spawn(|| <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> job = receiver.lock().unwrap().recv().unwrap();</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Worker &#123;&#125; got a job; executing."</span>, id);</span><br><span class="line">        job();</span><br><span class="line">    &#125;);</span><br><span class="line">    Worker&#123;</span><br><span class="line">        id, thread</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>看完了文档总结我的理解：</p>
<p>生命周期告诉 Rust 两个变量存活的时间长度</p>
<p>比如下面的代码，返回的 &amp;’a str 一定是 x <strong>或</strong> y，或者说，&amp;’a str 一定依赖了 x <strong>或</strong> y，</p>
<p>那通过生命周期标注 <code>&#39;a</code> 告诉 Rust 编译器返回的值生命周期是 x <strong>和</strong> y <strong>最小值</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> x.len() &gt; y.len() &#123;</span><br><span class="line">        x</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能在函数中返回局部变量的引用，函数调用完成 result 就被drop掉，所以返回的引用也是不合法的</p>
<p>这段代码过不了编译是因为 str 属于基本数据类型，调用结束函数栈就被pop掉，对于被pop掉的栈变量引用是不合法的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt;(x: &amp;<span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="built_in">String</span>::from(<span class="string">"really long string"</span>);</span><br><span class="line">    result.as_str()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，你可以返回 String</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = calculate_length();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>() -&gt; <span class="built_in">String</span> &#123; <span class="comment">// s is a reference to a String</span></span><br><span class="line">    <span class="built_in">String</span>::from(<span class="string">"123"</span>)</span><br><span class="line">&#125; <span class="comment">// H</span></span><br></pre></td></tr></table></figure>

<h4 id="‘static-生命周期"><a href="#‘static-生命周期" class="headerlink" title="‘static 生命周期"></a>‘static 生命周期</h4><p>简单介绍一个语句</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义 Job 类型， dyn FnOnce 是多态函数，只允许被调用一次，实现了 Send trait，'static生命周期</span></span><br><span class="line"><span class="comment">// Box 要求编译器将 Job 类型放到 heap 中</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">Job</span></span> = <span class="built_in">Box</span>&lt;<span class="keyword">dyn</span> <span class="built_in">FnOnce</span>() + <span class="built_in">Send</span> + <span class="symbol">'static</span>&gt;;</span><br></pre></td></tr></table></figure>

<h4 id="生命周期参数"><a href="#生命周期参数" class="headerlink" title="生命周期参数"></a>生命周期参数</h4><p>你调用函数时编译器只能知道函数的参数类型，但并不知道传递给函数的变量要存活多久，如果函数永远不返回那传递的参数就没法释放，所以需要函数标注生命周期来确定传递的参数可以和xxx存活时间一样长。</p>
<p><a href="https://www.reddit.com/r/rust/comments/bltnfv/simplest_best_explanation_of_lifetimes/emth1hk?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank" rel="noopener">https://www.reddit.com/r/rust/comments/bltnfv/simplest_best_explanation_of_lifetimes/emth1hk?utm_source=share&amp;utm_medium=web2x&amp;context=3</a><br><a href="https://www.reddit.com/r/rust/comments/bltnfv/simplest_best_explanation_of_lifetimes/emrev4p?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank" rel="noopener">https://www.reddit.com/r/rust/comments/bltnfv/simplest_best_explanation_of_lifetimes/emrev4p?utm_source=share&amp;utm_medium=web2x&amp;context=3</a></p>
<h3 id="Async，-Await-语义"><a href="#Async，-Await-语义" class="headerlink" title="Async， Await 语义"></a>Async， Await 语义</h3><p>再说 Rust 之前先用我最熟悉的 Javascript 举例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">readFileFromDisk</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">await</span> fs.readFile(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> pwd = <span class="keyword">await</span> readFromDisk(<span class="string">"/etc/passwd"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的 async function 会被翻译成这样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileFromDisk</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(path);</span><br><span class="line">&#125;</span><br><span class="line">readFromDisk(<span class="string">"/etc/passwd"</span>).then(<span class="function">(<span class="params">d</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> pwd = d;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>JS 的例子是将异步 IO 转换成 Promise，这个 Promise 对应的 Rust 中的 Future，Java 中的 CompletableFuture（Java 中的 Future 是个同步调用,override 掉 get 方法）</p>
<p>理解这样概念时要明白怎么实现的，OS 只认识线程</p>
<p>如果 FD（File descriptor） 被设置为 block，那 Read 时没有数据就会被阻塞，既然阻塞当前调用线程就会被挂起，很好理解，所谓的协程， green thread 只不过是用户空间构造出来的概念，OS 只认线程，所以 IO 调用被阻塞线程就作为人质被挂起</p>
<p>如果 FD 是 setBlocking(false)，那就引出现在主流的异步实现方案</p>
<p>这个方案借助了 OS 提供的 IO 等待阻塞原语 IO-aware system blocking primitive，当 Read 没有数据读时会直接返回，可以将 FD 注册给 OS 然后 poll 等待，等数据读时 OS 会唤醒你的调用线程</p>
<p>poll 有两个实现，单线程/多线程池</p>
<p>Rust 中的 mio 是一个单线程实现，Read，Write 都在一个线程</p>
<p>Tokio 借助 mio 实现了线程池方案</p>
<p>问题是常用的 select 方案对 File 支持不友好</p>
<p><a href="https://www.reddit.com/r/rust/comments/dh8ook/mio_for_file_operations/" target="_blank" rel="noopener">https://www.reddit.com/r/rust/comments/dh8ook/mio_for_file_operations/</a></p>
<p>现有的解决办法是开新的线程阻塞读取</p>
<p>两种阻塞方案<br>socket 的 read 不一定会有数据，epoll 在这种情况下可以封装事件循环</p>
<p>但如果你读取本地文件 read 一定会马上读取，如果对 file 使用 epoll，当调用 epoll_await 时马上会返回，因为文件这时已经就绪可读了</p>
<p>read 一定要放到某个 thread 才行，Linux 有的 AIO 了解一下</p>
<h3 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h3><h4 id="Rc-Reference-Counted"><a href="#Rc-Reference-Counted" class="headerlink" title="Rc - Reference Counted"></a>Rc - Reference Counted</h4><p>具有引用计数功能的指针，只能用于单线程</p>
<p>A，B，C，D 同时引用一块内存，如果知道 A 最长那可以将A设置为 ownership。但实际上不能确认谁的生命周期最长。Rc就是为了解决这个问题，它会在 count = 0 时释放内存。</p>
<h3 id="无惧并发"><a href="#无惧并发" class="headerlink" title="无惧并发"></a>无惧并发</h3><p>下面代码线程捕获了 v，但 Rust 并不能确定线程运行多长时间，也就不能明确释放时机</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">drop</span>(v); <span class="comment">// oh no!</span></span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以需要move语义，将线程引用的外层变量全部 take ownership，转移到线程上下文中。<br><a href="https://doc.rust-lang.org/book/ch16-01-threads.html" target="_blank" rel="noopener">https://doc.rust-lang.org/book/ch16-01-threads.html</a></p>
<h4 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语法杂项"><a href="#语法杂项" class="headerlink" title="语法杂项"></a>语法杂项</h3><h4 id="函数调用返回"><a href="#函数调用返回" class="headerlink" title="函数调用返回"></a>函数调用返回</h4><p>语句结束要加分号，如果没有分号表示 return</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">multiple</span></span>(first_number_str: &amp;<span class="built_in">str</span>, second_numer_str: &amp;<span class="built_in">str</span>) -&gt; <span class="built_in">Result</span>&lt;<span class="built_in">i32</span>, ParseIntError&gt; &#123;</span><br><span class="line">    <span class="comment">// 由于 parse 可能发生异常，这里返回Result，OK可以将如果成功的值解析出来</span></span><br><span class="line">    <span class="keyword">let</span> first_number = first_number_str.parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line">    <span class="keyword">let</span> second_number = second_numer_str.parse::&lt;<span class="built_in">i32</span>&gt;()?;</span><br><span class="line">    <span class="comment">// 这里没分号，返回了</span></span><br><span class="line">    <span class="literal">Ok</span>(first_number * second_number)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main 函数没有返回值，所以最后一行要添加分号</p>
<h4 id="闭包-closure-和-block"><a href="#闭包-closure-和-block" class="headerlink" title="闭包(closure) 和 block"></a>闭包(closure) 和 block</h4><p>看下面的代码， async 块并不是个 闭包 函数，而只是简单的 语法块，首先执行 async {}，然后返回的参数再传递给 <code>spawn</code>，那 spawn 拿到的就是个 Future 而不是 函数</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mini_tokio.spawn(<span class="keyword">async</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> when = Instant::now() + Duration::from_millis(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">let</span> future = Delay &#123; when &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> out = future.<span class="keyword">await</span>;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(out, <span class="string">"done"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Marco-宏-元编程"><a href="#Marco-宏-元编程" class="headerlink" title="Marco 宏 - 元编程"></a>Marco 宏 - 元编程</h4><p>Marco 可以理解为模式匹配，又或者为 正则表达式捕获组，匹配出特定模式的 token 来动态生成代码</p>
<p>test 宏支持重载，有两个写法。 expr 要求 left, right 必须为表达式(expression)</p>
<p>=&gt; () 中的内容是 marco 展开的 block</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> test &#123;</span><br><span class="line">    ($left: expr; and $right: expr) =&gt; (</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; and &#123;:?&#125; is &#123;:?&#125;"</span>,<span class="built_in">stringify!</span>($left),<span class="built_in">stringify!</span>($right), $left &amp;&amp; $right)</span><br><span class="line">    );</span><br><span class="line">    ($left: expr; or $right: expr) =&gt; (</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125; or &#123;:?&#125; is &#123;:?&#125;"</span>, <span class="built_in">stringify!</span>($left), <span class="built_in">stringify!</span>($right), $left || $right);</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    test!( <span class="number">1i32</span> + <span class="number">1</span> ==<span class="number">2i32</span>;and <span class="number">2i32</span> * <span class="number">2</span> == <span class="number">4i32</span>);</span><br><span class="line">    <span class="comment">// 这个也可以运行是由于Rust中 块(block) 也算是表达式</span></span><br><span class="line">    test!( <span class="number">1i32</span> + <span class="number">1</span> ==<span class="number">2i32</span>;and &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="number">2i32</span> * <span class="number">2</span> == <span class="number">4i32</span></span><br><span class="line">    &#125;);</span><br><span class="line">    test!( <span class="number">1</span> + <span class="number">2</span> == <span class="number">3</span>;or <span class="number">2</span> + <span class="number">3</span> == <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>rust 中表达式的含义更广泛，<a href="https://doc.rust-lang.org/reference/expressions.html" target="_blank" rel="noopener">https://doc.rust-lang.org/reference/expressions.html</a></p>
<p>看个更复杂的， ident 是个约束，要求 fn 必须是函数，右侧括号里是个正则， * 允许 0 到无穷多个，所以我在使用的时候添加,,,,,,编译也通过。</p>
<p>这里</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/**/</span>&#123;&#125;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>

<p>是个表达式，外层 {} 是宏定义外侧，内层的 {} 是块表达式</p>
<p>因为 Hexo 编译 markdown 会出错，所以用 /**/ 隔断下</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">=&gt; &#123;<span class="comment">/**/</span>&#123; <span class="comment">//</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line">&#125;<span class="comment">/**/</span>&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[allow(unused_macros)]</span></span><br><span class="line"><span class="built_in">macro_rules!</span> syscall &#123;</span><br><span class="line">    ($<span class="function"><span class="keyword">fn</span>: <span class="title">ident</span> </span>( $($arg: expr),* $(,)* ) ) =&gt; &#123;<span class="comment">/**/</span>&#123; <span class="comment">//</span></span><br><span class="line">        <span class="keyword">let</span> res = <span class="keyword">unsafe</span> &#123; libc::$<span class="function"><span class="keyword">fn</span></span>($($arg, )*) &#125;;</span><br><span class="line">        <span class="keyword">if</span> res == -<span class="number">1</span> &#123;</span><br><span class="line">            <span class="literal">Err</span>(std::io::Error::last_os_error())</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(res)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">/**/</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> ep = syscall!(epoll_create(<span class="number">19</span> + <span class="number">1</span>,,,,,,,,,,,)).map(|ep| ep).unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h4><p>没想到一个 struct 我竟然要单独学一些</p>
<p>已经习惯了如下写法</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果看 mio 时发现还有这样的 struct，我没想到 Token 之后可以直接括号，一直看不懂什么意思，也不好检索。</p>
<p>最后没办法了只能看下 RFC，结果发现 struct Token(pub usize) 叫做 tuple struct，可以认为这种struct 的字段是 0</p>
<p>RFC在此</p>
<p><a href="https://doc.rust-lang.org/reference/items/structs.html" target="_blank" rel="noopener">https://doc.rust-lang.org/reference/items/structs.html</a></p>
<p>这个过程告诉我们：</p>
<p>语言的语法其实没什么技术含量，看不懂这个语法可以看 RFC 学习，关键在于理解语法的内在含义，而不是表征</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Token</span></span>(<span class="keyword">pub</span> <span class="built_in">usize</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">From</span>&lt;Token&gt; <span class="keyword">for</span> <span class="built_in">usize</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">from</span></span>(val: Token) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">        val.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 struct 可以解释如下</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Token</span></span> &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h3><h4 id="String-和-str-区别"><a href="#String-和-str-区别" class="headerlink" title="String 和 str 区别"></a>String 和 str 区别</h4><p>String是个对象，存放在stack上的数据大小固定</p>
<p>str 是常量，但编译时不能判断具体的长度，所以 str 的内容存放在 静态存储区，通过 &amp;str 获取数据</p>
<h3 id="标准库解读"><a href="#标准库解读" class="headerlink" title="标准库解读"></a>标准库解读</h3><h4 id="Arc"><a href="#Arc" class="headerlink" title="Arc"></a>Arc</h4><blockquote>
<p>A thread-safe reference-counting pointer. ‘Arc’ stands for ‘Atomically Reference Counted’.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> (sender, receiver) = mpsc::channel();</span><br><span class="line"><span class="keyword">let</span> receiver = Arc::new(Mutex::new(receiver));</span><br></pre></td></tr></table></figure>

<p>想再说下 <a href="https://stackoverflow.com/questions/29413222/what-are-the-actual-uses-of-es6-weakmap" target="_blank" rel="noopener">WeakMap</a>，拿 Javascript举例。</p>
<p>可以理解为 WeakMap 里存放的是弱引用</p>
<p>是个引用：可以找到你存放的Object<br>又不完全是个引用，GC不会在乎 WeakMap 里的引用，如果没其他对象引用即使WeakMap存在引用也会被GC，相较于Map，WeakMap可以一定程度防止内存泄漏</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    doSomethingWith(obj);</span><br><span class="line">    <span class="keyword">var</span> called = map.get(obj) || <span class="number">0</span>;</span><br><span class="line">    called ++;</span><br><span class="line">    <span class="keyword">if</span> (called &gt; <span class="number">10</span>) report();</span><br><span class="line">    <span class="comment">// map 持有全部obj的引用永不释放</span></span><br><span class="line">    map.set(obj, called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果没有其他引用持有 obj们，那 GC 会自动清除 obj 且 map 中对原obj的引用也会被删除</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useObj</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    doSomethingWith(obj);</span><br><span class="line">    <span class="keyword">var</span> called = map.get(obj) || <span class="number">0</span>;</span><br><span class="line">    called ++;</span><br><span class="line">    <span class="keyword">if</span> (called &gt; <span class="number">10</span>) report();</span><br><span class="line">    map.set(obj, called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那 WeakMap 有啥引用场景呢？</p>
<p>最简单的是持有 DOM，一般而言 DOM 从DOM树上删除后就没用了，如果使用Map会造成 memory leak，这里使用 WeakMap 合适</p>
</div><div class="tags"><a href="/tags/Rust/">Rust</a><a href="/tags/编程语言/">编程语言</a></div><div class="post-nav"><a class="pre" href="/2021/06/08/54/">Rust-Pin提出的必要性-以及我对Pin的认识</a><a class="next" href="/2020/10/21/52/">数据表的设计</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '2e81634cb0a32c318015',
  clientSecret: '33f6723010778fe273d4cee4ebbeb931fc826d7a',
  repo: 'blogsuepost',
  owner: 'iamwwc',
  admin: [''],
  id: md5(location.pathname),
  number: +('53'),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/云计算/" style="font-size: 15px;">云计算</a> <a href="/tags/杂七杂八/" style="font-size: 15px;">杂七杂八</a> <a href="/tags/算法与数据结构/" style="font-size: 15px;">算法与数据结构</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/tags/Rust/" style="font-size: 15px;">Rust</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/06/08/54/">Rust-Pin提出的必要性-以及我对Pin的认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/01/53/">Rust浅尝</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/21/52/">数据表的设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/12/51/">Typescript动态类型推断</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/11/50/">Redux为什么需要中间件来处理异步数据流？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/11/49/">React Hook使用小记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/48/">Actor Model 编程模型浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/47/">Redux-thunk代码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/24/46/">我眼中的Redux</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/06/25/45/">读Go泛型提案有感</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 常年混迹于</i></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-GitHub"/></svg><a class="link" href="https://github.com/iamwwc" title="Github" target="_blank">Github</a></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu"/></svg><a class="link" href="https://www.zhihu.com/people/wu-wei-chao-97/activities" title="知乎" target="_blank">知乎</a></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo"/></svg><a class="link" href="https://weibo.com/6415416577/profile" title="微博" target="_blank">微博</a></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-CN_bilibiliB"/></svg><a class="link" href="https://space.bilibili.com/154206647" title="bilibili" target="_blank">bilibili</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div id="cp">Copyright © 2021 <a href="/." rel="nofollow">胖成煤气罐.</a></div><div id="beian"><a href="http://beian.miit.gov.cn/">鲁ICP备18026609号</a></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" defer></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>