<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="广阔天地，大有可为"><title>Rust声明周期 | 胖成煤气罐</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/normalize.min.css"><link rel="stylesheet" type="text/css" href="/css/pure-min.css"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><script type="text/javascript" src="/js/jquery.min.js"></script><link rel="icon" mask sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><style type="text/css">.icon {
  vertical-align: -0.15em;
  fill: currentColor;
  overflow: hidden;
}</style><script src="//at.alicdn.com/t/font_1484091_u5pgqyl62w9.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-148409521-1','auto');ga('send','pageview');
</script></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Rust声明周期</h1><a id="logo" href="/.">胖成煤气罐</a><p class="description">广阔天地，大有可为</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Rust声明周期</h1><div class="post-meta"><div class="post-date">2021-07-01</div><div class="post-tags"> | <a class="post-tag" href="/tags/Rust/">Rust</a></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2.2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><h1 id="声明周期的抽象"><a href="#声明周期的抽象" class="headerlink" title="声明周期的抽象"></a>声明周期的抽象</h1><p><strong>将LT想象成scope不太容易理解，可以将其想象成链。标注同一个的引用必须共存亡。通过 ‘a, 多个引用链在一起。</strong><br>![将引用比作绳子]](<a href="https://user-images.githubusercontent.com/24750337/114650520-fb8a8c80-9d14-11eb-93a0-3ee191ff4938.png" target="_blank" rel="noopener">https://user-images.githubusercontent.com/24750337/114650520-fb8a8c80-9d14-11eb-93a0-3ee191ff4938.png</a>)</p>
<p><a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html" target="_blank" rel="noopener">https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html</a><br><a href="https://www.zhihu.com/question/30861652/answer/132841992" target="_blank" rel="noopener">https://www.zhihu.com/question/30861652/answer/132841992</a></p>
<h1 id="为什么声明周期被如此设计"><a href="#为什么声明周期被如此设计" class="headerlink" title="为什么声明周期被如此设计"></a>为什么声明周期被如此设计</h1><p>跨函数的变量生存期分析及其复杂，要分析完成各种条件语句，且需要的值只有在运行时才能确认，这就加大了编译器分析的复杂度（又可认为不可能进行分析），Rust通过在函数，结构体上进行声明周期标注，将分析的范围限定到函数内部，从而完成整个分析的过程。这就是为何生命之后需要在 函数， 结构体 上进行 <code>&#39;a</code> 标注</p>
<p><a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html" target="_blank" rel="noopener">官方文档上有过类似的解释</a></p>
<blockquote>
<p>lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</p>
</blockquote>
<h2 id="生命周期和临时借用"><a href="#生命周期和临时借用" class="headerlink" title="生命周期和临时借用"></a>生命周期和临时借用</h2><h3 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h3><figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">'a</span>&gt; (&amp;<span class="symbol">'a</span> <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; NumRef&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method</span></span>(&amp;<span class="symbol">'a</span> <span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num_ref = NumRef(&amp;<span class="number">5</span>);</span><br><span class="line">    num_ref.some_method(); <span class="comment">// #1</span></span><br><span class="line">    num_ref.some_method(); <span class="comment">// #2</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, num_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面将 some_method 的 self 和整个 NumRef的 ‘a 关联，这意味着 some_method只能被调用一次。<br>rustc调用 #1 时借用了 self，由于 <code>&amp;&#39;a mut self</code>，所以 #1 调用完后也不能释放掉这次借用，第二次调用 some_method 出现第二次借用。</p>
<h3 id="纠正"><a href="#纠正" class="headerlink" title="纠正"></a>纠正</h3><figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NumRef</span></span>&lt;<span class="symbol">'a</span>&gt; (&amp;<span class="symbol">'a</span> <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>&gt; NumRef&lt;<span class="symbol">'a</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面省略了LT，desugar 后是</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">some_method_desugared</span></span>&lt;<span class="symbol">'b</span>&gt;(&amp;<span class="symbol">'b</span> <span class="keyword">mut</span> <span class="keyword">self</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num_ref = NumRef(&amp;<span class="number">5</span>);</span><br><span class="line">    num_ref.some_method();</span><br><span class="line">    num_ref.some_method();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, num_ref);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>‘b 和整个 struct 的 ‘a 无关，所以some_method的可变借用不需要和整个struct对齐，第二次调用可重新借用。</p>
<p>通过上面例子说明，代码能编译通过只是确保内存安全，声明周期的标注不一定是对的。</p>
<p>以上来自</p>
<blockquote>
<p><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#5-if-it-compiles-then-my-lifetime-annotations-are-correct" target="_blank" rel="noopener">https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#5-if-it-compiles-then-my-lifetime-annotations-are-correct</a></p>
</blockquote>
<h2 id="生命周期省略-‘"><a href="#生命周期省略-‘" class="headerlink" title="生命周期省略 ‘_"></a>生命周期省略 ‘_</h2><p><a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html#lifetime-elision" target="_blank" rel="noopener">https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html#lifetime-elision</a></p>
<blockquote>
<p>The first rule is that each parameter that is a reference gets its own lifetime parameter. In other words, a function with one parameter gets one lifetime parameter: fn foo&lt;’a&gt;(x: &amp;’a i32); a function with two parameters gets two separate lifetime parameters: fn foo&lt;’a, ‘b&gt;(x: &amp;’a i32, y: &amp;’b i32); and so on.<br>The second rule is if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters: fn foo&lt;’a&gt;(x: &amp;’a i32) -&gt; &amp;’a i32.<br>The third rule is if there are multiple input lifetime parameters, but one of them is &amp;self or &amp;mut self because this is a method, the lifetime of self is assigned to all output lifetime parameters. This third rule makes methods much nicer to read and write because fewer symbols are necessary.</p>
</blockquote>
<h3 id="生命周期何时可以省略呢？"><a href="#生命周期何时可以省略呢？" class="headerlink" title="生命周期何时可以省略呢？"></a>生命周期何时可以省略呢？</h3><p><strong>首先明确一点，Rust中每个引用都必须有生命周期，如果没写且编译通过，那属于生命周期省略</strong></p>
<p>生命周期下面简称 LT</p>
<ol>
<li>先将每个函数参数都标注唯一的 LT, ‘a, ‘b, ‘c, ‘d</li>
<li>如果入参只有一个LT，显而易见， 出参引用的生命周期一定会个 入参的 LT一致，也即，一个 入参引用 和 全部的出参 LT一样 </li>
<li>如果入参多个LT，且是成员函数（&amp;self 或 &amp;mut self），那全部的出参LT都和(&amp;self 或 &amp;mut self)一致。</li>
</ol>
<p>上述三个规则结束后，如果还有 出参 的LT没被确定，就必须<strong>显式</strong>添加LT标注</p>
<p>如果只有入参有引用，返回类型没引用，不需要标注生命周期。为什么呢？因为LT存在是防止空指针引用，如果返回值没引用函数内部的内存，就不会出现这个问题（单线程下）。</p>
<p>这个是官方的例子<br><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5c4baf83eac0666c47ef3b7b2ec027d9" target="_blank" rel="noopener">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=5c4baf83eac0666c47ef3b7b2ec027d9</a></p>
<p>下面的是我改的<br><a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3ae5b85c9f35375f866ad3ddfa3bee47" target="_blank" rel="noopener">https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2018&amp;gist=3ae5b85c9f35375f866ad3ddfa3bee47</a></p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Spawner</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> fmt::<span class="built_in">Debug</span> <span class="keyword">for</span> Spawner &#123;</span><br><span class="line">    <span class="comment">// fmt::Formatter 结构体又生命周期标注</span></span><br><span class="line">    <span class="comment">// struct Formatter&lt;'a&gt;</span></span><br><span class="line">    <span class="comment">// '_ 意思是我传递一个生命周期，这个周期以你Formatter&lt;'a&gt;为准</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">fmt</span></span>(&amp;<span class="keyword">self</span>, fmt: &amp;<span class="keyword">mut</span> fmt::Formatter&lt;<span class="symbol">'_</span>&gt;) -&gt; fmt::<span class="built_in">Result</span> &#123;</span><br><span class="line">        fmt.debug_struct(<span class="string">"Spawner"</span>).finish()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="‘static-声明周期"><a href="#‘static-声明周期" class="headerlink" title="‘static 声明周期"></a>‘static 声明周期</h2><p>当 struct 引用其他内存时需要声明周期标识</p>
<p>‘static 告诉编译器，这个 name 声明周期比 Person 结构体 无限长。</p>
<p><a href="https://www.reddit.com/r/rust/comments/o9w6rl/rust_traits_and_static/h3dszio?utm_source=share&amp;utm_medium=web2x&amp;context=3" target="_blank" rel="noopener">https://www.reddit.com/r/rust/comments/o9w6rl/rust_traits_and_static/h3dszio?utm_source=share&amp;utm_medium=web2x&amp;context=3</a></p>
<p>声明周期只是个标注，编译器根据标注进行声明周期推导，如果发现对不上还是会报错。</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span></span> &#123;</span><br><span class="line">    name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(name: &amp;<span class="symbol">'static</span> <span class="built_in">str</span>) -&gt; Person &#123;</span><br><span class="line">        Person &#123; name: name &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> nobody: Person = Person::new(<span class="string">"nobody"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>曾以为生命周期随便写也没关系。当你创建或者返回具有生命周期标识的struct时也必须在创建、赋值、返回时指明声明长度让编译器推导</p>
<p>比如下面</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span>(<span class="keyword">crate</span>) <span class="class"><span class="keyword">struct</span> <span class="title">BasicScheduler</span></span>&lt;P: Park&gt; &#123;</span><br><span class="line">    <span class="comment">/// Inner state guarded by a mutex that is shared</span></span><br><span class="line">    <span class="comment">/// between all `block_on` calls.</span></span><br><span class="line">    inner: Mutex&lt;<span class="built_in">Option</span>&lt;Inner&lt;P&gt;&gt;&gt;,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Notifier for waking up other threads to steal the</span></span><br><span class="line">    <span class="comment">/// parker.</span></span><br><span class="line">    notify: Notify,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Sendable task spawner</span></span><br><span class="line">    spawner: Spawner,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">InnerGuard</span></span>&lt;<span class="symbol">'a</span>, P: Park&gt; &#123;</span><br><span class="line">    inner: <span class="built_in">Option</span>&lt;Inner&lt;P&gt;&gt;,</span><br><span class="line">    basic_scheduler: &amp;<span class="symbol">'a</span> BasicScheduler&lt;P&gt;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span>&lt;P: Park&gt; BasicScheduler&lt;P&gt; &#123;</span><br><span class="line">    <span class="comment">// InnerGuard struct有周期标注，所以你返回时也必须进行标注</span></span><br><span class="line">    <span class="comment">// 这里还特殊的一点是，P 是个泛型，实现 Park 这个接口（trait）</span></span><br><span class="line">    <span class="comment">// &lt;&gt; 里同时带了 生命周期标注 和 泛型参数</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">take_inner</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;InnerGuard&lt;<span class="symbol">'_</span>,P&gt;&gt; &#123;</span><br><span class="line">        <span class="literal">Some</span>(InnerGuard &#123;</span><br><span class="line">            inner: <span class="literal">Some</span>(inner),</span><br><span class="line">            basic_scheduler: &amp;<span class="keyword">self</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生命周期只是个注解Annotation，告诉编译器你的引用存活到什么时间，但如果编译器推导出的生命长度与你的标注不同，编译器并不会帮你延长变量的存活期，而是会complain，编译出错让你再检查<br><a href="https://www.zhihu.com/question/30861652/answer/132841992" target="_blank" rel="noopener">https://www.zhihu.com/question/30861652/answer/132841992</a></p>
<h2 id="https-doc-rust-lang-org-stable-book-ch10-03-lifetime-syntax-html-lifetime-annotations-in-function-signatures"><a href="#https-doc-rust-lang-org-stable-book-ch10-03-lifetime-syntax-html-lifetime-annotations-in-function-signatures" class="headerlink" title="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures"></a><a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures" target="_blank" rel="noopener">https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html#lifetime-annotations-in-function-signatures</a></h2><p>当在函数上标注生命周期时，总是在函数签名，而不是函数体标注。在函数内部的变量编译器可以很轻松的分析，但对于引用的外部的变量，或者从函数参数传进来的变量，编译器无法自己分析，需要手动标注生命周期。</p>
<blockquote>
<p>When annotating lifetimes in functions, the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</p>
</blockquote>
<p>你如何标注生命周期取决于你的函数在做什么。如果我们将 longest 函数改为总是返回第一个入参，那我们不需要在y上标注。</p>
<p>比如</p>
<figure class="highlight rs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回参数只和 x 有关</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">longest</span></span>&lt;<span class="symbol">'a</span>&gt; (x: &amp;<span class="symbol">'a</span> <span class="built_in">str</span>, y: &amp;<span class="built_in">str</span>) -&gt; &amp;<span class="symbol">'a</span> <span class="built_in">str</span> &#123;</span><br><span class="line">    x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面例子中，只为 x 和返回值标注生命周期参数，这是因为 y 和 x，返回值的生命周期没有任何关系</p>
<h2 id="下面这段话很重要"><a href="#下面这段话很重要" class="headerlink" title="下面这段话很重要"></a>下面这段话很重要</h2><p>当从函数中返回引用时，返回值的生命周期参数<strong>必须匹配</strong>函数入参的其中之一。如果返回的引用和任何一个入参都没有关系，那返回值一定引用了在函数内创建的变量，这非常危险，因为离开函数作用域之后被引用的值会被销毁</p>
<blockquote>
<p>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does not refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the longest function that won’t compile:</p>
</blockquote>
<p>编写函数，结构体时，最简单的生命周期标注是给全部的引用都加上相同声明周期，这样最起码可以确保万无一失</p>
<p>如果函数某个引用&amp;c并不和其他引用有’a的关系，可以给&amp;c添加 ‘b，不过这种情况很少出现</p>
</div><div class="tags"><a href="/tags/Rust/">Rust</a></div><div class="post-nav"><a class="next" href="/2021/06/18/55/">Async状态机实现</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '2e81634cb0a32c318015',
  clientSecret: '33f6723010778fe273d4cee4ebbeb931fc826d7a',
  repo: 'blogsuepost',
  owner: 'iamwwc',
  admin: [''],
  id: md5(location.pathname),
  number: +('56'),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1 pure-u-md-1-4"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/转载/" style="font-size: 15px;">转载</a> <a href="/tags/Leetcode/" style="font-size: 15px;">Leetcode</a> <a href="/tags/Go/" style="font-size: 15px;">Go</a> <a href="/tags/基础/" style="font-size: 15px;">基础</a> <a href="/tags/云计算/" style="font-size: 15px;">云计算</a> <a href="/tags/杂七杂八/" style="font-size: 15px;">杂七杂八</a> <a href="/tags/算法与数据结构/" style="font-size: 15px;">算法与数据结构</a> <a href="/tags/翻译/" style="font-size: 15px;">翻译</a> <a href="/tags/前端/" style="font-size: 15px;">前端</a> <a href="/tags/数据库/" style="font-size: 15px;">数据库</a> <a href="/tags/Rust/" style="font-size: 15px;">Rust</a> <a href="/tags/年终总结/" style="font-size: 15px;">年终总结</a> <a href="/tags/编程语言/" style="font-size: 15px;">编程语言</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2021/07/01/56/">Rust声明周期</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/18/55/">Async状态机实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/06/08/54/">Rust-Pin提出的必要性-以及我对Pin的认识</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/11/01/53/">Rust浅尝</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/21/52/">数据表的设计</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/12/51/">Typescript动态类型推断</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/11/49/">React Hook使用小记录</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/10/11/50/">Redux为什么需要中间件来处理异步数据流？</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/09/15/48/">Actor Model 编程模型浅谈</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/08/25/47/">Redux-thunk代码分析</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 常年混迹于</i></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-GitHub"/></svg><a class="link" href="https://github.com/iamwwc" title="Github" target="_blank">Github</a></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-zhihu"/></svg><a class="link" href="https://www.zhihu.com/people/wu-wei-chao-97/activities" title="知乎" target="_blank">知乎</a></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-weibo"/></svg><a class="link" href="https://weibo.com/6415416577/profile" title="微博" target="_blank">微博</a></div><div class="icon-container"><svg class="icon" aria-hidden="true"><use xlink:href="#icon-CN_bilibiliB"/></svg><a class="link" href="https://space.bilibili.com/154206647" title="bilibili" target="_blank">bilibili</a></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer"><div id="cp">Copyright © 2021 <a href="/." rel="nofollow">胖成煤气罐.</a></div><div id="beian"><a href="http://beian.miit.gov.cn/">鲁ICP备18026609号</a></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="/js/jquery.fancybox.min.js" defer></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" defer></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>